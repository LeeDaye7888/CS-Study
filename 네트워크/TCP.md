## TCP
- 연결 지향적 프로토콜. 데이터의 신뢰성 보장. 데이터를 보낼 때 먼저 연결을 설정하고, 데이터 전송 후에는 연결 해제.
- 데이터 전송 과정에서 신뢰성 보장을 위해 오류 검출, 복구, 흐름 제어, 혼잡 제어 등 기능 수행.
- 데이터를 순차적으로 전송하며, 도착 순서를 보장. -> 이메일이나 파일 전송 등에 사용.
- TCP 헤더에는 송신자/수신자의 포트 번호, 순서 번호, 확인 응답 번호, 플래그 등의 정보 포함.
- 데이터 신뢰성 보장위해 상대적으로 오버헤드가 크고, 전송 속도가 느리다는 단점.


## 3way handshake - 연결 성립
정확한 전송 보장 위해 TCP는 3 way handshake 과정 진행.
1. 클라이언트가 서버에게 `SYN 패킷` 보냄
2. 서버가 SYN을 받고, 클라이언트에게 받았다는 신호인 `ACK`와 `SYN 패킷`을 보냄
3. 클라이언트는 서버가 보낸 응답 받고, `ACK`를 서버로 보냄.


## 4way handshake - 연결 해제
연결 성립 후, 모든 통신이 끝났다면 **해제**해야 한다.
1. 클라이언트는 서버에게 연결 종료한다는 `FIN 플래그`를 보냄
2. 서버는 FIN 받고, 확인했다는 `ACK`를 클라이언트에게 보냄(모든 데이터 보내기 위해 `CLOSE_WAIT` 상태)
3. 서버가 데이터를 모두 보냈다면, 서버는 연결이 종료되었다는 `FIN 플래그`를 클라이언트에게 보냄
4. 클라이언트는 FIN을 받고, 확인했다는 `ACK`를 서버에게 보냄. (아직 서버로부터 받지 못한 데이터 있을 수 있으니 `TIME_WAIT` 상태로 기다림)
서버는 ACK 받은 후, 소켓 Closed함.
TIME_WAIT 시간 끝나면 클라이언트도 Closed.


---

### TCP는 reliable network를 보장하는 프로토콜인데, 이것은 4가지 문제점 존재
- **손실** : 패킷(packet)이 손실될 수 있는 문제
- **순서 바뀜** : packet의 순서가 바뀌는 문제
- **Congestion** : 네트워크 혼잡 문제
- **Overload** : receiver가 overload 되는 문제

이를 해결하기 위해, TCP의 제어 방법이 있음

## 1. TCP의 흐름제어
**문제 발생**
1. 송신측의 속도 > 수신측의 속도일 경우: 송신측의 속도가 더 빠를 경우 문제 발생
2. 수신측에서 제한된 저장 용량 초과할 경우

**해결**
- `Stop and Wait` : 전송한 패킷에 대해 **매번 확인 응답을 받아야만**, 그 **다음 패킷 전송함**
- `Sliding Window` : 송신측 확인 **응답 없이**, **수신측**에서 설정한 **윈도우 크기만큼** 세그먼트를 **전송**할 수 있게 함. 데이터 흐름을 **동적으로** 조절


## 2. TCP의 혼잡 제어
송신측의 데이터는 대형 네트워크(지역망, 인터넷)를 통해 전달된다. 
만약 한 라우터에 데이터가 몰릴 경우, 데이터를 모두 처리하는 것이 불가능해져 호스트들은 계속 재전송 -> 혼잡 가중되어 `오버플로우`나 `데이터 손실` 발생.

이러한 **네트워크의 혼잡을 피하기 위해**, `송신측`에서 보내는 `데이터 전송 속도`를 **강제로 느리도록** 함: `혼잡제어`

- 혼잡: 네트워크 내에 **패킷의 수**가 **과도하게 증가**하는 현상
- 혼잡 제어: 혼잡 현상을 방지하거나 제거하는 기능(송신측 데이터 전송 속도를 강제로 늦춤!)

흐름제어는 송신측과 수신측 사이의 전송 속도를 다루지만, 혼잡제어는 호스트와 라우터를 포함한 더 넓은 관점의 전송 문제를 다룸.

### 1. 혼잡 제어 - AIMD (Additional Increase / Multiplicative Decrease)
처음에 패킷을 하나씩 보내고 문제없이 도착하면, `window 크기`(단위 시간 내에 보내는 패킷의 수)를 **1씩 증가**시키며 전송하는 방식.

- 패킷 전송에 실패하거나 일정 시간을 넘으면, 패킷의 보내는 **속도를 절반으로 줄인다.**
- 여러 호스트가 한 네트워크를 공유하고 있으면 나중에 진입하는 쪽이 **처음에는 불리**하지만 **시간이 흐르면** 평형 상태로 **공평한** 방식임.
- 문제점: **초기엔** 네트워크의 높은 대역폭을 사용하지 못하여 **오랜 시간** 소요. 네트워크의 혼잡을 미리 감지 못함. -> 네트워크가 **혼잡해지고 나서야 대역폭 줄임**.

### 2. 혼잡 제어 - Slow Start (느린 시작)
AIMD 방식이 네트워크 수용량 주변에서는 효율적으로 작동하지만, 전송 속도 부분에서 오래 걸리는 단점이 존재. <br>
**TCP의 초기 전송 속도를 조절**하는 알고리즘. <br>
Slow Start 방식은 AIMD와 마찬가지로 패킷을 하나씩 보내어 패킷이 문제없이 도착하면, 각각 ACK 패킷마다 window size를 1씩 늘려준다. -> 한 주기가 지나면 window size가 2배 됨.
- 전송 속도는 AIMD에 반해 **지수 함수 꼴로 증가**. 대신 **혼잡 현상이 발생**하면 **window size를 1로 줄인다**.
- 처음에는 네트워크의 수용량을 예상할 수 있는 정보가 없지만, **한번 혼잡 현상이 발생**하면 네트워크의 **수용량을 어느정도 예상** 가능.
- 그러므로 혼잡 현상이 발생했던 window size의 절반까지는 이전처럼 지수 함수 꼴로 window size 크기를 증가시키고, 그 이후부터는 완만하게 1씩 증가.

### 3. 혼잡 제어 - Fast Retransmit (빠른 재전송)
TCP의 혼잡 제어에 추가된 정책.

- 수신자는 **중복된 패킷을 감지**하면 이를 송신자에게 즉시 알려줌. 이를 통해 송신자는 패킷 손실을 빠르게 감지하고 **재전송** 요청.
- 중복된 순번의 패킷 3개를 받으면 재전송하게 됨. 재전송하고 window size를 줄인다.

### 4. 혼잡 제어 - Fast Recovery (빠른 회복)
- 혼잡 상태일 때 TCP의 빠른 복구를 위한 알고리즘. 패킷 손실 후 전송 속도를 빠르게 회복시키는 역할.
- 패킷 손실을 감지하면 전송 속도(window size)를 1로 줄이지 않고 **반으로 줄이고**, 수신자로부터 **중복 확인 응답(Duplicate ACK)을 받으면 전송 속도를 증가.**
